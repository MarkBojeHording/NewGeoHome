import { useState, useEffect, useMemo } from 'react'

// Utility function
const formatNumber = (num) => num.toLocaleString()

// Get countdown to first Thursday (matching your existing logic)
const getCountdown = () => {
  const now = new Date()
  let target = new Date(now.getFullYear(), now.getMonth(), 1)
  while (target.getDay() !== 4) target.setDate(target.getDate() + 1)
  target.setHours(14, 0, 0, 0)
  if (target <= now) {
    target = new Date(target.setMonth(target.getMonth() + 1))
    target.setDate(1)
    while (target.getDay() !== 4) target.setDate(target.getDate() + 1)
    target.setHours(14, 0, 0, 0)
  }
  
  const diff = target.getTime() - now.getTime()
  return {
    days: Math.floor(diff / (1000 * 60 * 60 * 24)),
    hours: Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)),
    fractionalDays: Math.floor(diff / (1000 * 60 * 60 * 24)) + Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)) / 24
  }
}

export default function TCUpkeepModal({ onClose }) {
  const [countdown, setCountdown] = useState(getCountdown())
  const [goodForWipe, setGoodForWipe] = useState(false)
  const [trackForTotal, setTrackForTotal] = useState(true)
  const [trackRemainingTime, setTrackRemainingTime] = useState(true)
  const [timerDays, setTimerDays] = useState('')
  const [timerHours, setTimerHours] = useState('')
  const [timerMinutes, setTimerMinutes] = useState('')
  const [isTimerActive, setIsTimerActive] = useState(false)
  const [showTCAdvanced, setShowTCAdvanced] = useState(false)
  const [mainTC, setMainTC] = useState({
    wood: '',
    stone: '',
    metal: '',
    hqm: ''
  })
  
  const [additionalTCs, setAdditionalTCs] = useState([])
  const [showAddModal, setShowAddModal] = useState(false)
  const [editingId, setEditingId] = useState(null)
  const [tcEntry, setTcEntry] = useState({
    name: '',
    woodUpkeep: 0,
    stoneUpkeep: 0,
    metalUpkeep: 0,
    hqmUpkeep: 0,
    remainingDays: '',
    remainingHours: '',
    remainingMinutes: ''
  })
  
  // Update wipe countdown
  useEffect(() => {
    const updateCountdown = () => setCountdown(getCountdown())
    updateCountdown()
    const interval = setInterval(updateCountdown, 60000)
    return () => clearInterval(interval)
  }, [])
  
  // Stop timer when tracking is disabled
  useEffect(() => {
    if (!trackRemainingTime) {
      setIsTimerActive(false)
    }
  }, [trackRemainingTime])
  
  // Timer countdown - decrements the actual field values every minute
  useEffect(() => {
    if (isTimerActive && trackRemainingTime) {
      const timer = setInterval(() => {
        // Calculate current total seconds
        const days = parseInt(timerDays) || 0
        const hours = parseInt(timerHours) || 0
        const minutes = parseInt(timerMinutes) || 0
        let totalSeconds = (days * 24 * 60 * 60) + (hours * 60 * 60) + (minutes * 60)
        
        if (totalSeconds <= 60) {
          // Timer expired
          setIsTimerActive(false)
          setTimerDays('00')
          setTimerHours('00')
          setTimerMinutes('00')
        } else {
          // Decrement by 1 minute
          totalSeconds -= 60
          const newDays = Math.floor(totalSeconds / (24 * 60 * 60))
          const newHours = Math.floor((totalSeconds % (24 * 60 * 60)) / (60 * 60))
          const newMinutes = Math.floor((totalSeconds % (60 * 60)) / 60)
          
          setTimerDays(newDays.toString().padStart(2, '0'))
          setTimerHours(newHours.toString().padStart(2, '0'))
          setTimerMinutes(newMinutes.toString().padStart(2, '0'))
        }
      }, 60000)  // Update every minute
      
      return () => clearInterval(timer)
    }
  }, [isTimerActive, timerDays, timerHours, timerMinutes, trackRemainingTime])
  
  const startTimer = () => {
    if (!trackRemainingTime) return
    
    const days = parseInt(timerDays) || 0
    const hours = parseInt(timerHours) || 0
    const minutes = parseInt(timerMinutes) || 0
    
    if (hours > 23 || minutes > 59) return
    
    const totalSeconds = (days * 24 * 60 * 60) + (hours * 60 * 60) + (minutes * 60)
    if (totalSeconds > 0) {
      setIsTimerActive(true)
    }
  }
  
  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      e.target.blur()
    }
  }
  
  const handleInputChange = (setter, value, max) => {
    // Allow typing but validate max
    if (value === '' || (parseInt(value) >= 0 && parseInt(value) <= max)) {
      setter(value)
    }
  }
  
  const handleBlur = () => {
    if (!isTimerActive) {
      startTimer()
    }
  }
  
  // Calculate if timer should show red (less than 10 minutes)
  const isLowTime = () => {
    const days = parseInt(timerDays) || 0
    const hours = parseInt(timerHours) || 0
    const minutes = parseInt(timerMinutes) || 0
    const totalSeconds = (days * 24 * 60 * 60) + (hours * 60 * 60) + (minutes * 60)
    return isTimerActive && totalSeconds <= 600
  }
  
  // Helper to get numeric value from mainTC (treat empty string as 0)
  const getNumericValue = (value) => {
    return value === '' ? 0 : Number(value)
  }
  
  // Calculate totals
  const totals = useMemo(() => {
    // Start with MainTC upkeep if tracking for total (convert empty strings to 0)
    let daily = trackForTotal ? {
      wood: getNumericValue(mainTC.wood),
      stone: getNumericValue(mainTC.stone),
      metal: getNumericValue(mainTC.metal),
      hqm: getNumericValue(mainTC.hqm)
    } : { wood: 0, stone: 0, metal: 0, hqm: 0 }
    
    // Add upkeep from external TCs
    additionalTCs.forEach(tc => {
      daily.wood = (daily.wood || 0) + tc.woodUpkeep
      daily.stone = (daily.stone || 0) + tc.stoneUpkeep
      daily.metal = (daily.metal || 0) + tc.metalUpkeep
      daily.hqm = (daily.hqm || 0) + tc.hqmUpkeep
    })
    
    // Calculate until wipe
    const untilWipe = {}
    Object.keys(daily).forEach(key => {
      untilWipe[key] = Math.ceil(daily[key] * countdown.fractionalDays)
    })
    
    return { daily, untilWipe }
  }, [mainTC, additionalTCs, countdown.fractionalDays, trackForTotal])
  
  // Calculate optimal TC storage distribution
  const calculateOptimalStorage = useMemo(() => {
    const daily = {
      wood: getNumericValue(mainTC.wood),
      stone: getNumericValue(mainTC.stone),
      metal: getNumericValue(mainTC.metal),
      hqm: getNumericValue(mainTC.hqm)
    }
    const SLOTS = 24
    const STACK_LIMITS = { wood: 1000, stone: 1000, metal: 1000, hqm: 100 }
    
    // Skip if no upkeep
    const totalDaily = daily.wood + daily.stone + daily.metal + daily.hqm
    if (totalDaily === 0) {
      return { slots: Array(SLOTS).fill({ type: 'empty' }), maxDays: 0, totalMaterials: {} }
    }
    
    // Initialize slot allocation
    let slotAllocation = { wood: 0, stone: 0, metal: 0, hqm: 0 }
    let remainingSlots = SLOTS
    
    // Allocate slots to maximize minimum days
    while (remainingSlots > 0) {
      let worstType = null
      let worstDays = Infinity
      
      // Find which resource runs out first (has least days)
      Object.keys(daily).forEach(type => {
        if (daily[type] > 0) {
          const currentCapacity = slotAllocation[type] * STACK_LIMITS[type]
          const days = currentCapacity / daily[type]
          if (days < worstDays) {
            worstDays = days
            worstType = type
          }
        }
      })
      
      if (worstType) {
        slotAllocation[worstType]++
        remainingSlots--
      } else {
        break
      }
    }
    
    // Calculate actual max days (limited by resource that runs out first)
    let maxDays = Infinity
    Object.keys(daily).forEach(type => {
      if (daily[type] > 0) {
        const capacity = slotAllocation[type] * STACK_LIMITS[type]
        const days = capacity / daily[type]
        maxDays = Math.min(maxDays, days)
      }
    })
    
    // Cap max days at wipe time
    const daysUntilWipe = countdown.fractionalDays
    const effectiveMaxDays = Math.min(maxDays, daysUntilWipe)
    
    // Build slot array with actual amounts (capped at wipe)
    const slots = []
    Object.keys(slotAllocation).forEach(type => {
      if (slotAllocation[type] > 0) {
        const stackLimit = STACK_LIMITS[type]
        const totalNeeded = Math.min(
          slotAllocation[type] * stackLimit,
          Math.floor(daily[type] * effectiveMaxDays)
        )
        
        for (let i = 0; i < slotAllocation[type]; i++) {
          const remaining = totalNeeded - (i * stackLimit)
          const amount = Math.min(stackLimit, Math.max(0, remaining))
          if (amount > 0) {
            slots.push({ type, amount })
          }
        }
      }
    })
    
    // Fill remaining with empty
    while (slots.length < SLOTS) {
      slots.push({ type: 'empty' })
    }
    
    // Calculate total materials needed (actual amounts in TC, capped at wipe)
    const totalMaterials = {}
    Object.keys(daily).forEach(type => {
      if (slotAllocation[type] > 0) {
        const stackLimit = STACK_LIMITS[type]
        totalMaterials[type] = Math.min(
          slotAllocation[type] * stackLimit,
          Math.floor(daily[type] * effectiveMaxDays)
        )
      }
    })
    
    return { 
      slots, 
      maxDays: maxDays === Infinity ? 0 : maxDays,
      effectiveMaxDays: effectiveMaxDays === Infinity ? 0 : effectiveMaxDays,
      totalMaterials,
      daysUntilWipe
    }
  }, [mainTC, countdown.fractionalDays])
  
  const handleSaveTC = () => {
    if (!tcEntry.name.trim()) return
    
    if (editingId) {
      setAdditionalTCs(tcs => tcs.map(tc => 
        tc.id === editingId ? { ...tc, ...tcEntry } : tc
      ))
      setEditingId(null)
    } else {
      setAdditionalTCs([...additionalTCs, {
        id: Date.now(),
        ...tcEntry
      }])
    }
    
    setTcEntry({ name: '', woodUpkeep: 0, stoneUpkeep: 0, metalUpkeep: 0, hqmUpkeep: 0, remainingDays: '', remainingHours: '', remainingMinutes: '' })
    setShowAddModal(false)
  }
  
  const handleEditTC = (tc) => {
    setTcEntry({
      name: tc.name,
      woodUpkeep: tc.woodUpkeep || 0,
      stoneUpkeep: tc.stoneUpkeep,
      metalUpkeep: tc.metalUpkeep,
      hqmUpkeep: tc.hqmUpkeep,
      remainingDays: tc.remainingDays || '',
      remainingHours: tc.remainingHours || '',
      remainingMinutes: tc.remainingMinutes || ''
    })
    setEditingId(tc.id)
    setShowAddModal(true)
  }
  
  const handleDeleteTC = (id) => {
    setAdditionalTCs(additionalTCs.filter(tc => tc.id !== id))
  }
  
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={onClose}>
      <style>{`
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
          -webkit-appearance: none;
          margin: 0;
        }
        input[type="number"] {
          -moz-appearance: textfield;
        }
      `}</style>
      <div className="bg-white rounded-lg shadow-xl" style={{ width: '400px' }} onClick={e => e.stopPropagation()}>
        {/* Header */}
        <div className="flex justify-between items-center px-3 py-1 border-b">
          <div className="flex items-center space-x-4">
            <label className="flex items-center text-xs">
              <input 
                type="checkbox" 
                checked={goodForWipe}
                onChange={e => setGoodForWipe(e.target.checked)}
                className="mr-1"
              />
              Good for wipe
            </label>
            <label className="flex items-center text-xs">
              <input 
                type="checkbox" 
                checked={trackForTotal}
                onChange={e => setTrackForTotal(e.target.checked)}
                className="mr-1"
              />
              Track for total
            </label>
            <label className="flex items-center text-xs" title="Enable to track and countdown remaining upkeep time">
              <input 
                type="checkbox" 
                checked={trackRemainingTime}
                onChange={e => setTrackRemainingTime(e.target.checked)}
                className="mr-1"
              />
              Track time
            </label>
          </div>
          <button onClick={onClose} className="text-gray-500 hover:text-gray-700 text-lg leading-none">√ó</button>
        </div>
        
        {/* Main TC Section */}
        <div className="px-3 py-2 border-b">
          <div className="flex justify-between items-center mb-1">
            <span className="text-xs font-semibold text-gray-700">Main TC Daily Upkeep</span>
            <div className="flex items-center">
              <input
                type="text"
                placeholder="DD"
                value={timerDays}
                onChange={e => handleInputChange(setTimerDays, e.target.value, 99)}
                onKeyPress={handleKeyPress}
                onBlur={handleBlur}
                disabled={!trackRemainingTime}
                className={`w-8 border rounded-l px-1 text-xs text-center font-mono ${
                  !trackRemainingTime ? 'bg-gray-100 text-gray-400 cursor-not-allowed' :
                  isLowTime() ? 'text-red-600 font-bold' : ''
                }`}
                maxLength="2"
              />
              <span className={`text-xs px-0.5 ${!trackRemainingTime ? 'text-gray-400' : ''}`}>:</span>
              <input
                type="text"
                placeholder="HH"
                value={timerHours}
                onChange={e => handleInputChange(setTimerHours, e.target.value, 23)}
                onKeyPress={handleKeyPress}
                onBlur={handleBlur}
                disabled={!trackRemainingTime}
                className={`w-8 border-y px-1 text-xs text-center font-mono ${
                  !trackRemainingTime ? 'bg-gray-100 text-gray-400 cursor-not-allowed' :
                  isLowTime() ? 'text-red-600 font-bold' : ''
                }`}
                maxLength="2"
              />
              <span className={`text-xs px-0.5 ${!trackRemainingTime ? 'text-gray-400' : ''}`}>:</span>
              <input
                type="text"
                placeholder="MM"
                value={timerMinutes}
                onChange={e => handleInputChange(setTimerMinutes, e.target.value, 59)}
                onKeyPress={handleKeyPress}
                onBlur={handleBlur}
                disabled={!trackRemainingTime}
                className={`w-8 border rounded-r px-1 text-xs text-center font-mono ${
                  !trackRemainingTime ? 'bg-gray-100 text-gray-400 cursor-not-allowed' :
                  isLowTime() ? 'text-red-600 font-bold' : ''
                }`}
                maxLength="2"
              />
            </div>
          </div>
          <div className="grid grid-cols-4 gap-1">
            {['wood', 'stone', 'metal', 'hqm'].map(type => (
              <div key={type}>
                <label className="text-xs text-gray-600 block">{type.toUpperCase()}</label>
                <input
                  type="number"
                  value={mainTC[type]}
                  onChange={e => setMainTC({ ...mainTC, [type]: e.target.value })}
                  className="w-full border rounded px-1 py-0.5 text-sm"
                  min="0"
                  placeholder=""
                />
              </div>
            ))}
          </div>
        </div>
        
        {/* External TCs Section */}
        <div className="px-3 py-2 border-b">
          <div className="flex justify-between items-center mb-1">
            <div className="flex items-center space-x-2">
              <span className="text-xs font-semibold text-gray-700">External TCs</span>
              <button
                onClick={() => setShowTCAdvanced(true)}
                className={`px-2 py-0.5 text-white text-xs rounded ${
                  (() => {
                    // Check if any upkeep is set
                    const hasUpkeep = getNumericValue(mainTC.wood) > 0 || getNumericValue(mainTC.stone) > 0 || 
                                     getNumericValue(mainTC.metal) > 0 || getNumericValue(mainTC.hqm) > 0
                    if (!hasUpkeep) return 'bg-red-500 hover:bg-red-600'
                    
                    // If not tracking time, default to red
                    if (!trackRemainingTime) return 'bg-red-500 hover:bg-red-600'
                    
                    // Check current time vs wipe time
                    const days = parseInt(timerDays) || 0
                    const hours = parseInt(timerHours) || 0
                    const minutes = parseInt(timerMinutes) || 0
                    const currentTimeInDays = days + (hours / 24) + (minutes / (24 * 60))
                    
                    return currentTimeInDays >= countdown.fractionalDays
                      ? 'bg-green-500 hover:bg-green-600'
                      : 'bg-red-500 hover:bg-red-600'
                  })()
                }`}
                title={(() => {
                  if (!trackRemainingTime) return "Enable time tracking to see status"
                  
                  const days = parseInt(timerDays) || 0
                  const hours = parseInt(timerHours) || 0
                  const minutes = parseInt(timerMinutes) || 0
                  const currentTimeInDays = days + (hours / 24) + (minutes / (24 * 60))
                  
                  if (currentTimeInDays >= countdown.fractionalDays) {
                    return "TC is good for wipe!"
                  } else {
                    return "TC needs more resources for wipe"
                  }
                })()}
              >
                TC Advanced
              </button>
            </div>
            <button
              onClick={() => {
                setTcEntry({ name: '', woodUpkeep: 0, stoneUpkeep: 0, metalUpkeep: 0, hqmUpkeep: 0, remainingDays: '', remainingHours: '', remainingMinutes: '' })
                setEditingId(null)
                setShowAddModal(true)
              }}
              className="px-2 py-1 bg-green-500 text-white text-xs rounded hover:bg-green-600"
            >
              + Add TC
            </button>
          </div>
          <div className="border rounded max-h-40 overflow-y-auto overflow-x-hidden">
            <div className="flex justify-between items-center py-1 px-2 border-b text-xs font-medium bg-gray-50">
              <div className="flex items-center">
                <span className="w-20 text-[11px]">Time</span>
                <span className="border-l pl-2 w-24">Name:</span>
              </div>
              <div className="flex items-center space-x-8">
                <span className="w-40 text-center">Upkeep per day</span>
                <div className="flex items-center space-x-1">
                  <span>Edits</span>
                  <button
                    type="button"
                    onClick={() => {
                      setTcEntry({ name: '', woodUpkeep: 0, stoneUpkeep: 0, metalUpkeep: 0, hqmUpkeep: 0, remainingDays: '', remainingHours: '', remainingMinutes: '' })
                      setEditingId(null)
                      setShowAddModal(true)
                    }}
                    className="w-4 h-4 bg-green-500 text-white rounded-full text-xs hover:bg-green-600 flex-shrink-0"
                  >
                    +
                  </button>
                </div>
              </div>
            </div>
            
            {additionalTCs.length === 0 ? (
              <div className="py-1.5 px-3 text-xs text-gray-500 text-center">No external TCs added</div>
            ) : (
              additionalTCs.map(tc => {
                const days = parseInt(tc.remainingDays) || 0
                const hours = parseInt(tc.remainingHours) || 0
                const minutes = parseInt(tc.remainingMinutes) || 0
                const hasTime = days > 0 || hours > 0 || minutes > 0
                const timeInDays = days + (hours / 24) + (minutes / (24 * 60))
                const isGoodForWipe = timeInDays >= countdown.fractionalDays
                
                return (
                  <div key={tc.id} className={`flex justify-between text-xs py-0.5 px-2 border-b last:border-b-0 ${
                    isGoodForWipe ? 'bg-green-50' : ''
                  }`}>
                    <div className="flex items-center">
                      <div className="w-20 text-[10px] font-mono">
                        {hasTime ? (
                          isGoodForWipe ? (
                            <span className="text-green-600 font-semibold text-[9px]">‚úì Good for wipe</span>
                          ) : (
                            <span>{`${days}d ${hours}h ${minutes}m`}</span>
                          )
                        ) : (
                          <span className="text-gray-400">-</span>
                        )}
                      </div>
                      <span className="border-l pl-2 w-24 truncate">{tc.name}</span>
                    </div>
                    <div className="flex items-center space-x-8">
                      <div className="flex space-x-2 w-40 justify-center">
                        {tc.woodUpkeep > 0 && <span>W:{tc.woodUpkeep}</span>}
                        {tc.stoneUpkeep > 0 && <span>S:{tc.stoneUpkeep}</span>}
                        {tc.metalUpkeep > 0 && <span>M:{tc.metalUpkeep}</span>}
                        {tc.hqmUpkeep > 0 && <span>H:{tc.hqmUpkeep}</span>}
                      </div>
                      <div className="flex space-x-1">
                        <button
                          onClick={() => handleEditTC(tc)}
                          className="text-blue-500 flex-shrink-0"
                        >
                          ‚úèÔ∏è
                        </button>
                        <button
                          onClick={() => handleDeleteTC(tc.id)}
                          className="text-red-500 flex-shrink-0"
                        >
                          üóëÔ∏è
                        </button>
                      </div>
                    </div>
                  </div>
                )
              })
            )}
          </div>
        </div>
        
        {/* Totals Section */}
        <div className="px-3 py-2 bg-gray-50 rounded-b-lg">
          <div className="grid grid-cols-2 gap-3 text-xs">
            {/* Daily Total */}
            <div>
              <div className="font-semibold text-gray-700 mb-1">Total Daily Upkeep</div>
              {Object.entries(totals.daily).map(([type, value]) => (
                value > 0 && (
                  <div key={type} className="flex justify-between">
                    <span className="text-gray-600">{type.toUpperCase()}:</span>
                    <span className="font-bold">{formatNumber(value)}</span>
                  </div>
                )
              ))}
            </div>
            
            {/* Until Wipe */}
            <div>
              <div className="font-semibold text-gray-700 mb-1">
                Until Wipe ({countdown.days}d {countdown.hours}h)
              </div>
              {Object.entries(totals.untilWipe).map(([type, value]) => {
                if (value === 0) return null
                const boxSize = type === 'hqm' ? 4800 : (type === 'wood' ? 100000 : 48000)
                const boxes = Math.ceil(value / boxSize)
                return (
                  <div key={type} className="flex justify-between">
                    <span className="text-gray-600">{type.toUpperCase()}:</span>
                    <span>
                      <span className="font-bold text-red-600">{formatNumber(value)}</span>
                      <span className="text-gray-500 text-[10px] ml-1">({boxes} {boxes === 1 ? 'box' : 'boxes'})</span>
                    </span>
                  </div>
                )
              })}
            </div>
          </div>
        </div>
      </div>
      
      {/* Add/Edit TC Modal */}
      {showAddModal && (
        <div className="fixed inset-0 bg-black bg-opacity-30 flex items-center justify-center z-[60]" onClick={() => {
          setShowAddModal(false)
          setEditingId(null)
          setTcEntry({ name: '', woodUpkeep: 0, stoneUpkeep: 0, metalUpkeep: 0, hqmUpkeep: 0, remainingDays: '', remainingHours: '', remainingMinutes: '' })
        }}>
          <div className="bg-white rounded p-4 shadow-lg" onClick={e => e.stopPropagation()}>
            <div className="text-sm font-medium mb-3">{editingId ? 'Edit TC' : 'Add TC'}</div>
            <div className="space-y-3">
              <input
                type="text"
                placeholder="Name"
                value={tcEntry.name}
                onChange={e => setTcEntry({ ...tcEntry, name: e.target.value })}
                className="w-full border rounded px-2 py-1 text-sm"
              />
              
              {/* Remaining Time Inputs */}
              <div>
                <label className="text-xs text-gray-600 block mb-1">Remaining Time (optional)</label>
                <div className="flex items-center space-x-1">
                  <input
                    type="text"
                    placeholder="DD"
                    value={tcEntry.remainingDays}
                    onChange={e => {
                      const value = e.target.value
                      if (value === '' || (parseInt(value) >= 0 && parseInt(value) <= 99)) {
                        setTcEntry({ ...tcEntry, remainingDays: value })
                      }
                    }}
                    className="w-12 border rounded px-1 py-1 text-sm text-center"
                    maxLength="2"
                  />
                  <span className="text-xs">:</span>
                  <input
                    type="text"
                    placeholder="HH"
                    value={tcEntry.remainingHours}
                    onChange={e => {
                      const value = e.target.value
                      if (value === '' || (parseInt(value) >= 0 && parseInt(value) <= 23)) {
                        setTcEntry({ ...tcEntry, remainingHours: value })
                      }
                    }}
                    className="w-12 border rounded px-1 py-1 text-sm text-center"
                    maxLength="2"
                  />
                  <span className="text-xs">:</span>
                  <input
                    type="text"
                    placeholder="MM"
                    value={tcEntry.remainingMinutes}
                    onChange={e => {
                      const value = e.target.value
                      if (value === '' || (parseInt(value) >= 0 && parseInt(value) <= 59)) {
                        setTcEntry({ ...tcEntry, remainingMinutes: value })
                      }
                    }}
                    className="w-12 border rounded px-1 py-1 text-sm text-center"
                    maxLength="2"
                  />
                </div>
              </div>
              
              {/* Upkeep Inputs */}
              <div>
                <label className="text-xs text-gray-600 block mb-1">Daily Upkeep</label>
                <div className="grid grid-cols-4 gap-2">
                  <div>
                    <label className="text-xs text-gray-600">Wood/day</label>
                    <input
                      type="number"
                      value={tcEntry.woodUpkeep}
                      onChange={e => setTcEntry({ ...tcEntry, woodUpkeep: Number(e.target.value) })}
                      className="w-full border rounded px-2 py-1 text-sm"
                      min="0"
                    />
                  </div>
                  <div>
                    <label className="text-xs text-gray-600">Stone/day</label>
                    <input
                      type="number"
                      value={tcEntry.stoneUpkeep}
                      onChange={e => setTcEntry({ ...tcEntry, stoneUpkeep: Number(e.target.value) })}
                      className="w-full border rounded px-2 py-1 text-sm"
                      min="0"
                    />
                  </div>
                  <div>
                    <label className="text-xs text-gray-600">Metal/day</label>
                    <input
                      type="number"
                      value={tcEntry.metalUpkeep}
                      onChange={e => setTcEntry({ ...tcEntry, metalUpkeep: Number(e.target.value) })}
                      className="w-full border rounded px-2 py-1 text-sm"
                      min="0"
                    />
                  </div>
                  <div>
                    <label className="text-xs text-gray-600">HQM/day</label>
                    <input
                      type="number"
                      value={tcEntry.hqmUpkeep}
                      onChange={e => setTcEntry({ ...tcEntry, hqmUpkeep: Number(e.target.value) })}
                      className="w-full border rounded px-2 py-1 text-sm"
                      min="0"
                    />
                  </div>
                </div>
              </div>
              
              <div className="flex justify-end gap-2">
                <button
                  onClick={() => {
                    setShowAddModal(false)
                    setEditingId(null)
                    setTcEntry({ name: '', woodUpkeep: 0, stoneUpkeep: 0, metalUpkeep: 0, hqmUpkeep: 0, remainingDays: '', remainingHours: '', remainingMinutes: '' })
                  }}
                  className="px-3 py-1 text-sm border rounded hover:bg-gray-100"
                >
                  Cancel
                </button>
                <button
                  onClick={handleSaveTC}
                  className="px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700"
                >
                  Save
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
      
      {/* TC Advanced Modal */}
      {showTCAdvanced && (
        <div className="fixed inset-0 bg-black bg-opacity-30 flex items-center justify-center z-[60]" onClick={() => setShowTCAdvanced(false)}>
          <div className="bg-white rounded p-4 shadow-lg" style={{ width: '360px', maxHeight: '90vh', overflowY: 'auto' }} onClick={e => e.stopPropagation()}>
            <div className="flex justify-between items-center mb-3">
              <h3 className="text-sm font-bold">TC Advanced - Maximum Upkeep</h3>
              <button onClick={() => setShowTCAdvanced(false)} className="text-gray-500 hover:text-gray-700">√ó</button>
            </div>
            
            {/* 24 Slot Grid */}
            <div className="border rounded p-2 mb-3">
              <div className="grid grid-cols-6 gap-0">
                {calculateOptimalStorage.slots.map((slot, i) => (
                  <div 
                    key={i} 
                    className={`w-10 h-10 border flex flex-col items-center justify-center text-xs font-bold
                      ${slot.type === 'empty' ? 'bg-gray-50 border-gray-300' : 
                        slot.type === 'wood' ? 'bg-yellow-600 border-yellow-700 text-white' :
                        slot.type === 'stone' ? 'bg-gray-600 border-gray-700 text-white' :
                        slot.type === 'metal' ? 'bg-gray-500 border-gray-600 text-white' :
                        'bg-blue-600 border-blue-700 text-white'}`}
                  >
                    {slot.type !== 'empty' && (
                      <>
                        <span className="text-[10px] leading-none">
                          {slot.type === 'wood' ? 'W' : 
                           slot.type === 'stone' ? 'S' :
                           slot.type === 'metal' ? 'M' : 'HQM'}
                        </span>
                        <span className="text-[10px]">{slot.amount}</span>
                      </>
                    )}
                  </div>
                ))}
              </div>
            </div>
            
            {/* Summary */}
            <div className="text-xs space-y-2">
              <div className="font-semibold text-gray-700">
                Days until wipe: 
                <span className="text-purple-600 ml-1">
                  {Math.floor(calculateOptimalStorage.daysUntilWipe)} days {Math.floor((calculateOptimalStorage.daysUntilWipe % 1) * 24)} hours
                </span>
              </div>
              
              {/* Current TC Status based on timer */}
              {(() => {
                const days = parseInt(timerDays) || 0
                const hours = parseInt(timerHours) || 0
                const minutes = parseInt(timerMinutes) || 0
                const currentTimeInDays = days + (hours / 24) + (minutes / (24 * 60))
                const daysUntilWipe = calculateOptimalStorage.daysUntilWipe
                
                if ((currentTimeInDays > 0 || isTimerActive) && calculateOptimalStorage.effectiveMaxDays > 0 && trackRemainingTime) {
                  const currentInTC = {}
                  const neededToFill = {}
                  
                  // Check if already good for wipe
                  const isGoodForWipe = currentTimeInDays >= daysUntilWipe
                  
                  Object.keys(mainTC).forEach(type => {
                    const numericValue = getNumericValue(mainTC[type])
                    if (numericValue > 0) {
                      currentInTC[type] = Math.floor(numericValue * currentTimeInDays)
                      // Only need to fill up to wipe time, not beyond
                      const maxNeeded = Math.floor(numericValue * daysUntilWipe)
                      neededToFill[type] = Math.max(0, Math.min(
                        (calculateOptimalStorage.totalMaterials[type] || 0) - currentInTC[type],
                        maxNeeded - currentInTC[type]
                      ))
                    }
                  })
                  
                  return (
                    <>
                      <div className="border-t pt-2">
                        <div className="font-semibold text-gray-700 mb-1">
                          Currently in TC ({days}d {hours}h {minutes}m remaining):
                        </div>
                        <div className="grid grid-cols-2 gap-2 mb-2">
                          {Object.entries(currentInTC).map(([type, amount]) => (
                            amount > 0 && (
                              <div key={type} className="flex justify-between">
                                <span className="text-gray-600">{type.toUpperCase()}:</span>
                                <span className="text-blue-600">{formatNumber(amount)}</span>
                              </div>
                            )
                          ))}
                        </div>
                        
                        {isGoodForWipe && (
                          <div className="font-semibold text-green-600">
                            ‚úì Already good for wipe! ({currentTimeInDays.toFixed(1)} days > {daysUntilWipe.toFixed(1)} days to wipe)
                          </div>
                        )}
                      </div>
                      
                      {/* Resources Needed section */}
                      {calculateOptimalStorage.effectiveMaxDays > 0 && (
                        <div>
                          <div className="font-semibold text-gray-700 mb-1">
                            Resources Needed {calculateOptimalStorage.effectiveMaxDays >= calculateOptimalStorage.daysUntilWipe ? "(for full wipe)" : `(until max: ${Math.floor(calculateOptimalStorage.effectiveMaxDays)}d ${Math.floor((calculateOptimalStorage.effectiveMaxDays % 1) * 24)}h)`}:
                            {calculateOptimalStorage.maxDays > calculateOptimalStorage.daysUntilWipe && calculateOptimalStorage.effectiveMaxDays < calculateOptimalStorage.daysUntilWipe && (
                              <span className="text-xs text-gray-500 ml-1">
                                (capped from {Math.floor(calculateOptimalStorage.maxDays)}d)
                              </span>
                            )}
                          </div>
                          <div className="grid grid-cols-2 gap-2 mb-2">
                            {Object.entries(calculateOptimalStorage.totalMaterials).map(([type, amount]) => (
                              <div key={type} className="flex justify-between">
                                <span className="text-gray-600">{type.toUpperCase()}:</span>
                                <span className="font-bold">{formatNumber(amount)}</span>
                              </div>
                            ))}
                          </div>
                        </div>
                      )}
                      
                      {/* Need to add for wipe - moved to bottom */}
                      {!isGoodForWipe && (
                        <div className="border-t pt-2">
                          <div className="font-semibold text-gray-700 mb-1">
                            Need to add for wipe
                            {daysUntilWipe - currentTimeInDays > 0 && (
                              <span className="text-green-600 ml-1">
                                (+{Math.floor(daysUntilWipe - currentTimeInDays)}d {Math.floor(((daysUntilWipe - currentTimeInDays) % 1) * 24)}h to reach wipe)
                              </span>
                            )}:
                          </div>
                          <div className="grid grid-cols-2 gap-2">
                            {Object.entries(neededToFill).map(([type, amount]) => {
                              const boxSize = type === 'hqm' ? 4800 : (type === 'wood' ? 100000 : 48000)
                              const boxes = Math.ceil(amount / boxSize)
                              return amount > 0 && (
                                <div key={type} className="flex justify-between">
                                  <span className="text-gray-600">{type.toUpperCase()}:</span>
                                  <span>
                                    <span className="font-bold text-red-600">{formatNumber(amount)}</span>
                                    {amount > 0 && (
                                      <span className="text-gray-500 text-[10px] ml-1">
                                        ({boxes} {boxes === 1 ? 'box' : 'boxes'})
                                      </span>
                                    )}
                                  </span>
                                </div>
                              )
                            })}
                          </div>
                        </div>
                      )}
                    </>
                  )
                }
                return null
              })()}
              
              {/* Show Resources Needed if no timer is active */}
              {(() => {
                const days = parseInt(timerDays) || 0
                const hours = parseInt(timerHours) || 0
                const minutes = parseInt(timerMinutes) || 0
                const currentTimeInDays = days + (hours / 24) + (minutes / (24 * 60))
                
                if (!((currentTimeInDays > 0 || isTimerActive) && calculateOptimalStorage.effectiveMaxDays > 0 && trackRemainingTime)) {
                  return calculateOptimalStorage.effectiveMaxDays > 0 && (
                    <div>
                      <div className="font-semibold text-gray-700 mb-1">
                        Resources Needed {calculateOptimalStorage.effectiveMaxDays >= calculateOptimalStorage.daysUntilWipe ? "(for full wipe)" : `(until max: ${Math.floor(calculateOptimalStorage.effectiveMaxDays)}d ${Math.floor((calculateOptimalStorage.effectiveMaxDays % 1) * 24)}h)`}:
                        {calculateOptimalStorage.maxDays > calculateOptimalStorage.daysUntilWipe && calculateOptimalStorage.effectiveMaxDays < calculateOptimalStorage.daysUntilWipe && (
                          <span className="text-xs text-gray-500 ml-1">
                            (capped from {Math.floor(calculateOptimalStorage.maxDays)}d)
                          </span>
                        )}
                      </div>
                      <div className="grid grid-cols-2 gap-2 mb-2">
                        {Object.entries(calculateOptimalStorage.totalMaterials).map(([type, amount]) => (
                          <div key={type} className="flex justify-between">
                            <span className="text-gray-600">{type.toUpperCase()}:</span>
                            <span className="font-bold">{formatNumber(amount)}</span>
                          </div>
                        ))}
                      </div>
                    </div>
                  )
                }
                return null
              })()} 
              
              <div className="text-[10px] text-gray-500 border-t pt-2">
                Resources are optimized to last until wipe. No materials are wasted on upkeep beyond the wipe time.
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}